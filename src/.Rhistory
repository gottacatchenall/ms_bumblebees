f()
install.packages('Benchmarking')
state = rand()
coords = runif(np*2)
coords = runif(5*2)
reshape(coords, (5,2))
reshape(coords, 5,2)
reshape(coords)
dims(coords) = (5,2)
dims(coords) = c(5,2)
dim(coords) = c(5,2)
coords
random_dispersal_potential = function(np, alpha){
coords = runif(np*2)
dim(coords) = c(np,2)
Phi = zeros(np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 != p2){
d_ij = sqrt((coords[p1,1]-coords[p2,1])^2 + (coords[p1,2] - coords[p2,2])^2)
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
for (p2 in 1:np){
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
}
random_dispersal_potential(10, 3)
random_dispersal_potential = function(np, alpha){
coords = runif(np*2)
dim(coords) = c(np,2)
Phi = matrix(0, np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 != p2){
d_ij = sqrt((coords[p1,1]-coords[p2,1])^2 + (coords[p1,2] - coords[p2,2])^2)
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
for (p2 in 1:np){
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
}
random_dispersal_potential(10, 3)
d = random_dispersal_potential(10, 3)
d
random_dispersal_potential = function(np, alpha){
coords = runif(np*2)
dim(coords) = c(np,2)
Phi = matrix(0, np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 != p2){
d_ij = sqrt((coords[p1,1]-coords[p2,1])^2 + (coords[p1,2] - coords[p2,2])^2)
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
for (p2 in 1:np){
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
return(Phi)
}
d = random_dispersal_potential(10, 3)
d
random_dispersal_potential = function(np, alpha){
coords = runif(np*2)
dim(coords) = c(np,2)
Phi = matrix(0, np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 != p2){
d_ij = sqrt((coords[p1,1]-coords[p2,1])^2 + (coords[p1,2] - coords[p2,2])^2)
Phi[p1,p2] = exp(-1*alpha*d_ij)
}
}
for (p2 in 1:np){
Phi[p1,p2] = Phi[p1,p2] / sum(Phi[p1,])
}
}
return(Phi)
}
d = random_dispersal_potential(10, 3)
d
diffusion_dispersal = function(Phi, m, state){
np = length(state)
diffusion_matrix = matrix(0, np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 == p2){
diffusion_matrix[p1,p2] = 1 - m
}
else{
diffusion_matrix[p1,p2] = Phi[p1,p2] *m
}
}
}
new_state = rep(0, np)
for (i in 1:np){
for (j in 1:np){
new_state[i] = new_state[i] + diffusion_matrix[p1,p2] * state[p2]
}
}
return(new_state)
}
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, rand(10))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
runif(10, min=10, max=30)
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal = function(Phi, m, state){
np = length(state)
diffusion_matrix = matrix(0, np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 == p2){
diffusion_matrix[p1,p2] = 1 - m
}
else{
diffusion_matrix[p1,p2] = Phi[p1,p2] *m
}
}
}
new_state = rep(0, np)
for (i in 1:np){
for (j in 1:np){
new_state[i] = new_state[i] + diffusion_matrix[p2,p1] * state[p2]
}
}
return(new_state)
}
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal = function(Phi, m, state){
np = length(state)
diffusion_matrix = matrix(0, np,np)
for (p1 in 1:np){
for (p2 in 1:np){
if (p1 == p2){
diffusion_matrix[p1,p2] = 1 - m
}
else{
diffusion_matrix[p1,p2] = Phi[p1,p2] *m
}
}
}
new_state = rep(0, np)
for (i in 1:np){
for (j in 1:np){
new_state[i] = new_state[i] + diffusion_matrix[j,i] * state[j]
}
}
return(new_state)
}
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
diffusion_dispersal(random_dispersal_potential(10, 3), 0.2, runif(10, min=10, max=30))
run_simulation = function(
dispersal_model = diffusion_dispersal,
alpha = 3,
np = 20,
nt = 50,
chi = 0.02,
lambda = 5 ,
){
np = 10
nt = 40
trajectory = zeros(nt, np)
trajectory[1,] = runif(np)
Phi = random_dispersal_potential(np, alpha)
for (t in 2:nt){
state = trajectory[t-1,]
state = dispersal_model(Phi, m, state)
state = ricker(state, lambda, R, chi)
trajectory[t,] = state
}
return(trajectory)
}
run_simulation = function(
dispersal_model = diffusion_dispersal,
alpha = 3,
np = 20,
nt = 50,
chi = 0.02,
lambda = 5
){
np = 10
nt = 40
trajectory = zeros(nt, np)
trajectory[1,] = runif(np)
Phi = random_dispersal_potential(np, alpha)
for (t in 2:nt){
state = trajectory[t-1,]
state = dispersal_model(Phi, m, state)
state = ricker(state, lambda, R, chi)
trajectory[t,] = state
}
return(trajectory)
}
run_simulation = function(
dispersal_model = diffusion_dispersal,
alpha = 3,
np = 20,
nt = 50,
chi = 0.02,
lambda = 5
){
np = 10
nt = 40
trajectory = matrix(0, nt, np)
trajectory[1,] = runif(np)
Phi = random_dispersal_potential(np, alpha)
for (t in 2:nt){
state = trajectory[t-1,]
state = dispersal_model(Phi, m, state)
state = ricker(state, lambda, R, chi)
trajectory[t,] = state
}
return(trajectory)
}
run_simulation()
ricker_local = function(N, lambda, R, chi){
return(rpois(N*lambda*R*exp(-1*chi*N)))
}
ricker = function(state, lambda=5, R=0.9, chi=0.03){
new_state = zeros(length(state))
for (st in 1:length(state)) {
new_state[st] = ricker_local(state[st], lambda, R, chi)
}
return(new_state)
}
ricker_local = function(N, lambda, R, chi){
return(rpois(N*lambda*R*exp(-1*chi*N)))
}
ricker = function(state, lambda, R, chi){
new_state = zeros(length(state))
for (st in 1:length(state)) {
new_state[st] = ricker_local(state[st], lambda, R, chi)
}
return(new_state)
}
run_simulation()
ricker_local = function(N, lambda, R, chi){
return(rpois(N*lambda*R*exp(-1*chi*N)))
}
ricker = function(state, lambda, R, chi){
new_state = rep(0, length(state))
for (st in 1:length(state)) {
new_state[st] = ricker_local(state[st], lambda, R, chi)
}
return(new_state)
}
run_simulation()
run_simulation = function(
dispersal_model = diffusion_dispersal,
alpha = 3,
np = 20,
nt = 50,
chi = 0.02,
R = 0.9,
lambda = 5
){
np = 10
nt = 40
trajectory = matrix(0, nt, np)
trajectory[1,] = runif(np)
Phi = random_dispersal_potential(np, alpha)
for (t in 2:nt){
state = trajectory[t-1,]
state = dispersal_model(Phi, m, state)
state = ricker(state, lambda, R, chi)
trajectory[t,] = state
}
return(trajectory)
}
run_simulation()
ricker_local = function(N, l, R, chi){
return(rpois(lambda=N*l*R*exp(-1*chi*N)))
}
run_simulation()
ricker_local = function(N, l, R, chi){
return(rpois(1, lambda=N*l*R*exp(-1*chi*N)))
}
run_simulation()
run_simulation()
t = run_simulation()
size(t)
dim(t)
ccf
ccf(runif(10), runif(10))
o = ccf(runif(10), runif(10))
o$lag
ccf(runif(10), runif(10))
ccf(runif(10), runif(10), lag.max = 0)
o = ccf(runif(10), runif(10), lag.max = 0)
o$lag
o$acf
o$acf[1,1]
o$acf[1,]
o$acf
o$acf[,,1]
o$acf[,1,1]
o$acf[1,1,1]
pcc = function(trajectory){
np = dim(trajectory)[2]
nt = dim(trajectory)[1]
pcc = 0
ct = 0
for (p1 in 1:np){
for (p2 in (p1+1):np){
cc =ccf(trajectory[,p1], trajectory[,,p2], lag.max=0)
pcc = pcc + cc$acf[1,1,1]
ct = ct +1
}
}
return(pcc/ct)
}
pcc(t)
pcc = function(trajectory){
np = dim(trajectory)[2]
nt = dim(trajectory)[1]
pcc = 0
ct = 0
for (p1 in 1:np){
for (p2 in (p1+1):np){
cc =ccf(trajectory[,p1], trajectory[,p2], lag.max=0)
pcc = pcc + cc$acf[1,1,1]
ct = ct +1
}
}
return(pcc/ct)
}
pcc(t)
acf
pcc = function(trajectory){
np = dim(trajectory)[2]
nt = dim(trajectory)[1]
pcc = 0
ct = 0
for (p1 in 1:np){
for (p2 in (p1+1):np){
cc =ccf(trajectory[,p1], trajectory[,p2], lag.max=0)
pcc = pcc + cc$acf[1,1,1]
ct = ct +1
}
}
return(pcc/ct)
}
pcc(t)
pcc = function(trajectory){
np = dim(trajectory)[1]
nt = dim(trajectory)[2]
pcc = 0
ct = 0
for (p1 in 1:np){
for (p2 in (p1+1):np){
cc =ccf(trajectory[,p1], trajectory[,p2], lag.max=0)
pcc = pcc + cc$acf[1,1,1]
ct = ct +1
}
}
return(pcc/ct)
}
pcc(t)
np
t
dim(trajectory)[2]
dim(t)[2]
pcc = function(trajectory){
np = dim(trajectory)[2]
nt = dim(trajectory)[1]
pcc = 0
ct = 0
for (p1 in 1:np){
for (p2 in 1:np){
if (p2 >p1){
cc = ccf(trajectory[,p1], trajectory[,p2], lag.max=0)
pcc = pcc + cc$acf[1,1,1]
ct = ct +1
}
}
}
return(pcc/ct)
}
dim(t)[2]
pcc(t)
pcc(t)
pcc(t)
M = seq(0,1, by=0.01)
_R = c(0.9)
num_treatments = length(seq_M) * length(seq_LAMBDA) * length(seq_R) * length(seq_CHI) * length(seq_ALPHA)
seq_M = seq(0,1, by=0.01)
seq_LAMBDA = c(3,6,9,12)
seq_R = c(0.9)
seq_CHI = c(0.03)
seq_ALPHA = c(0.0)
num_treatments = length(seq_M) * length(seq_LAMBDA) * length(seq_R) * length(seq_CHI) * length(seq_ALPHA)
seq_M = seq(0,1, by=0.01)
seq_LAMBDA = c(3,6,9,12)
seq_R = c(0.9)
seq_CHI = c(0.03)
seq_ALPHA = c(0.0)
reps = 30
num_treatments = length(seq_M) * length(seq_LAMBDA) * length(seq_R) * length(seq_CHI) * length(seq_ALPHA) * reps
df = data.frame(
m = rep(0, num_treatments),
lambda = rep(0, num_treatments),
r = rep(0, num_treatments),
chi = rep(0, num_treatments),
alpha = rep(0, num_treatments),
pcc = rep(0, num_treatments)
)
# awful nested loop
np = 15
nt = 40
row = 1
for (m in seq_M){
for (lambda in seq_LAMBDA){
for (R in seq_R){
for (chi in seq_CHI){
for (alpha in seq_ALPHA){
for (r in 1:reps){
t = run_simulation(
dispersal_model = diffusion_dispersal,
alpha = alpha,
chi = chi,
R = R,
lambda = R,
np = np,
nt = nt
)
df[row,] = c(m,lambda,r,chi,alpha,pcc(t))
row = row +1
}
}
}
}
}
}
load("~/Downloads/data.rdata")
View(data)
mj = read.csv("~/Downloads/mj - Form Responses 1.csv")
mood = read.csv("~/Downloads/mood and weather - Form Responses 2.csv")
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
mj = read.csv("~/Downloads/mj - Form Responses 1.csv")
mood = read.csv("~/Downloads/mood and weather - Form Responses 2.csv")
merge(mj,  mood)
merge
?merge
library(dplyr)
install.packages("dplyr")
library(dplyr)
mj %>% full_join(mood)
df = mj %>% full_join(mood)
head(df)
ggplot(df, aes(Timestamp)) + geom_point(aes(Timestamp, temperature))
ggplot(df) + geom_point(aes(Timestamp, temperature))
df[order(as.Date(d$Datetime, format="%d/%m/%Y")),]
df[order(as.Date(df$Datetime, format="%d/%m/%Y")),]
df[order(as.Date(df$Timestamp, format="%d/%m/%Y")),]
full = mj %>% full_join(mood)
df = full[order(as.Date(full$Timestamp, format="%d/%m/%Y")),]
head(df)
ggplot(df) + geom_point(aes(Timestamp, temperature))
df[!is.na(df$temperature)] %>%  ggplot() + geom_point(aes(Timestamp, temperature))
df[[!is.na(df$temperature)]] %>%  ggplot() + geom_point(aes(Timestamp, temperature))
df %>%select_if(~ !any(is.na(.))) %>%  ggplot() + geom_point(aes(Timestamp, temperature))
df %>%select_if(~ (is.na(.$temperature))) %>%  ggplot() + geom_point(aes(Timestamp, temperature))
df %>%select_if(~ (is.na(.temperature))) %>%  ggplot() + geom_point(aes(Timestamp, temperature))
df %>%select_if(~ (is.na(temperature))) %>%  ggplot() + geom_point(aes(Timestamp, temperature))
df %>%select_if(~ (is.na(temperature))) %>%  ggplot() + geom_point(aes(Timestamp, temperature))
select
library(phytools)
setwd("/home/michael/papers/ms_bumblebees/src/")
df = read.csv("rawdata/bumblebee_interactions.csv")
names(df)
beetree = read.nexus("bee_consensus.tree")
planttree = read.nexus("clipped_consensus.tree")
df =read.csv("tmpmetaweb.csv")
df = df[!is.na(df$plant),]
dev.new(width = 15, height=12)
dev.new(width = 15, height=12)
dev.off()
dev.off()
pdf(width = 15, height=12)
co = cophylo(planttree,beetree, rotate=FALSE)
plot(co)
plot(co, cex=0.1)
pdf(width = 15, height=12)
co = cophylo(planttree,beetree, rotate=FALSE, cex=0.1)
plot(co, cex=0.1)
dev.off()
dev.off()
dev.off()
pdf(width = 15, height=12)
co = cophylo(planttree,beetree, rotate=FALSE, cex=0.1)
plot(co, cex=0.1)
dev.off()
pdf(width = 25, height=20)
co = cophylo(planttree,beetree, rotate=FALSE, cex=0.1)
plot(co, cex=0.1)
dev.off()
